/**
 * Capitalization Filter uses a dictionary (hash-map) to check if an
 * input word is capitalized correctly. Pass the properly capitalized
 * word to the `.add` method.
 */
function CapitalizationFilter( passIfUnknown ){
	this._words = {};
	this.passIfUnknown = passIfUnknown;
}
CapitalizationFilter.prototype.add = function( word ){
	this._words[word.toLowerCase()] = word;
};
CapitalizationFilter.prototype.test = function( word ){
	var lowerCaseWord = word.toLowerCase();
	if( this._words.hasOwnProperty( lowerCaseWord ) ){
		return (word == this._words[lowerCaseWord]);
	}else{
		return this.passIfUnknown;
	}
};
CapitalizationFilter.prototype.suggest = function( word ){
	var lowerCaseWord = word.toLowerCase();
	if( this._words.hasOwnProperty( lowerCaseWord ) ){
		return this._words[lowerCaseWord];
	}
	return '';
};

/**
 * WordFilter is the abstract base class (or interface) for the
 * things that will be used to mark/match words in some way.
 */
function WordFilter(){
}
WordFilter.prototype.add = function(word){
	// adds the words to the list
	// returns nothing
}
WordFilter.prototype.test = function(word){
	// returns true if the word is in the list
	// returns false if the word is not in the list
}
WordFilter.prototype.suggest = function( word ){
	// returns a suggestion based on the error
}

// NOTE: Cuckoo may be better than bloom
// https://github.com/vijayee/cuckoo-filter
/**
 * WordFilterBloom uses a bloom filter to test is a word is in the
 * list. Since it is a bloom filter it can tell if a word is
 * *definitely not* in the list. However, it can only tell if a word
 * is probably in the list. This means it may think some words are in
 * the list (returns true) when they are not.
 * Takes constant time to make this assessment regardless of the size
 * of the word list O(1).
 * Memory is O(1) because it does not store everyword.
 */
function WordFilterBloom(){
	this._bloomFilter = new BloomFilter(
		32 * 256, // number of bits to allocate.
		4        // number of hash functions.
	);
}
WordFilterBloom.prototype.add = function(word){
	this._bloomFilter.add( word );
}
WordFilterBloom.prototype.test = function(word){
	return this._bloomFilter.test( word );
}
WordFilterBloom.prototype.suggest = function( word ){
	return '';
}

/**
 * WordFilterListSearch stores the words as a list and searches
 * through the list for a word.
 * The more words in the list the longer it takes to search O(n).
 * Under the hood there may be some optimizations which make it
 * run in O(log(n)), by sorting the list.
 * Memory use is O(n) because it stores every word.
 */
function WordFilterListSearch(){
	this._words = [];
}
WordFilterListSearch.prototype.add = function(word){
	this._words.push( word );
}
WordFilterListSearch.prototype.test = function(word){
	return (this._words.indexOf( word ) > -1);
}
WordFilterListSearch.prototype.suggest = function( word ){
	return '';
}

/**
 * WordFilterHashMap uses a hashmap (implemented as a javascript
 * object) to store words in the list.
 * May run into issues with words that match built-in js keywords.
 * Speed: O(1)
 * Memory: O(n)
 */
function WordFilterHashMap(){
	this._words = {};
}
WordFilterHashMap.prototype.add = function(word){
	this._words[word] = 0;
}
WordFilterHashMap.prototype.test = function(word){
	return this._words.hasOwnProperty(word);
}
WordFilterHashMap.prototype.suggest = function( word ){
	return '';
}

/**
 * Controls conversion from multiline html text (as generated by
 * contentEdible things in a webpage) to plain text.
 */
function NewLineManager(){
}
NewLineManager.prototype.htmlToPlain = function( html ){
	// replace all <br>'s with '\n'
	// then remove ALL the tags
	var result = html;
	result = result.replace(/(<br>)?((<\/p>)|(<\/div>))/gi, '\n' );
	result = result.replace(/<br>/gi, '\n' );
	result = result.replace(/(<([^>]+)>)/gi, "");
	return result;
}
NewLineManager.prototype.plainToHtml = function( text ){
	var result = text;
	// result = result.replace(/\n/gi, '<br>' );
	result = result.replace(/\n/g, '</p><p>' );
	result = '<p>'+result+'</p>';
	result = result.replace(/<p><\/p>/g, '<p><br/></p>'); 
	return result;
}

/**
 * Words and non-words are used so we can "normalize" whitespace for
 * word comparision with grammars and other rules. And then we can
 * reconstruct the original text with the original whitespace and
 * punctuation.
 */
function Word( raw ){
	this.raw = raw;
	this.annotations = [];
}
Word.prototype.isWord = function(){
	return true;
}
Word.prototype.isNonWord = function(){
	return false;
}
Word.prototype.addAnnotation = function( annotation ){
	this.annotations.push( annotation );
}
Word.prototype.asString = function(){
	return this.raw;
}
function NonWord( raw ){
	this.raw = raw;
}
NonWord.prototype.isWord = function(){
	return false;
}
NonWord.prototype.isNonWord = function(){
	return true;
}
NonWord.prototype.addAnnotation = function( annotation ){
	// should not do anything, non-words do not have annotations
	return;
}

function Annotation( message, type ){
	this.message = message;
	this.type = type;
}
Annotation.prototype.apply = function( data ){
	return new Annotation( this.message.replace('$1',data), this.type );
}

function AnnotatedHtmlGenerator(){
}
function TippyHtmlGenerator( selectorClass ){
	this.selectorClass = selectorClass;
}
TippyHtmlGenerator.prototype.generateHtmlForWord = function( word ){
	var cssClasses = [this.selectorClass];
	var messages = [];
	for( var i=0,l=word.annotations.length; i<l; i+=1 ){
		var annotation = word.annotations[i]
		cssClasses.push( annotation.type );
		messages.push( annotation.message );
	}
	var output = '';
	output += '<span ';
	output += ' class="'+ cssClasses.join(' ') +'"';
	output += ' data-tippy-content="'+ messages.join('<br/>') +'"';
	output += '>';
	output += word.raw;
	output += '</span>';
	return output;
}

/**
 * The TextWordAnalyzer splits raw_text into Words and NonWords.
 * Words can be "tested" against a checker and annotated. After
 * the annotation is completed - html can be generated which
 * contains the annotations.
 * Note: this has too many responsibilities and should be refactored
 * in the future if anything is added to it.
 */
function TextWordAnalyzer( raw_text ){
	this._raw = raw_text;
	this._parts = [];
	this._wordIndexes = [];
	this._wordCounts = {};
	this._divideIntoWords();
	this._computeProperties();	
}
TextWordAnalyzer.prototype._divideIntoWords = function(){
	var _rawParts = this._raw.split(/\b/);
	for( var i=0, l=_rawParts.length; i<l; i+=1 ){
		var part = _rawParts[i];
		// only check the first character -- assume the rest of the
		// word is in the same "class"
		if( this._isSplitter( part[0] ) ){
			this._parts.push( new NonWord( part ) );
		}else{
			this._parts.push( new Word( part ) );
		}
	}
};
TextWordAnalyzer.prototype._computeProperties = function(){
	for( var i=0,l=this._parts.length; i<l; i+=1 ){
		var part = this._parts[i];
		if( part.isWord() ){
			this._wordIndexes.push( i );
			if( ! this._wordCounts.hasOwnProperty(part.raw) ){
				this._wordCounts[ part.raw ] = 0;
			}
			this._wordCounts[ part.raw ] += 1;
		}
	}
};
TextWordAnalyzer.prototype.getWordCount = function(){
	return this._wordIndexes.length;
};
TextWordAnalyzer.prototype._isSplitter = function( character ){
	var nonAlphas = ' .,-!"\';:#$%&~()\t*+/<=>?@\^_`{|}[]';
	return nonAlphas.indexOf( character ) > -1;
};
TextWordAnalyzer.prototype._getWord = function( index ){
	return this._parts[ this._wordIndexes[index] ];
};
TextWordAnalyzer.prototype.indexOf = function(textWordAnalyzer){
	var that = textWordAnalyzer;
	// We cannot contain a larger substring than our length
	var thatCount = that.getWordCount();
	var thisCount = this.getWordCount();
	if( thatCount > thisCount ){
		return -1;
	}
	for( var a=0; a<thisCount; a+=1 ){
		for( var b=0; b<thatCount; b+=1 ){
			if( this._getWord(a+b).raw != that._getWord(b).raw ){
				break;
			}
		}
		if( b == thatCount ){
			return a;
		}
	}
	return -1;
};
TextWordAnalyzer.prototype.markFailures = function( filter, annotation ){
	for( var a=0; a<this.getWordCount(); a+=1 ){
		var word = this._getWord(a);
		if( ! filter.test( word.raw.toLowerCase() ) ){
			var suggestion = filter.suggest( word.raw.toLowerCase() );
			word.addAnnotation(annotation.apply(suggestion));
		}
	}
}
TextWordAnalyzer.prototype.markMatches = function( filter, annotation ){
	for( var a=0; a<this.getWordCount(); a+=1 ){
		var word = this._getWord(a);
		if( filter.test( word.raw.toLowerCase() ) ){
			var suggestion = filter.suggest( word.raw.toLowerCase() );
			word.addAnnotation(annotation.apply(suggestion));
		}
	}
}
TextWordAnalyzer.prototype.generateTippy = function(){
	// Todo: make a separate class OutputGenerator?
	var output = '';
	var tippyGenerator = new TippyHtmlGenerator('has-tooltip');
	for( var i=0, l=this._parts.length; i<l; i+=1 ){
		var part = this._parts[i];
		if( part.isWord() && part.annotations.length > 0 ){
			output += tippyGenerator.generateHtmlForWord( part );
		}else{
			output += part.raw;
		}
	}
	return output;
}
